// -*- coding: utf-8 -*-
//
// disktest - Hard drive tester
//
// Copyright 2020 Michael Buesch <m@bues.ch>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
//

mod args;
mod disktest;
mod generator;
mod kdf;
mod seed;
mod stream;
mod stream_aggregator;
mod util;

use anyhow as ah;
use args::parse_args;
use crate::seed::{gen_seed_string, print_generated_seed};
use disktest::Disktest;
use signal_hook;
use std::env::args_os;
use std::fs::OpenOptions;
use std::path::Path;
use std::sync::Arc;
use std::sync::atomic::AtomicBool;

/// Length of the seed generated by --gen-seed.
const DEFAULT_GEN_SEED_LEN: usize = 70;

/// Install abort signal handlers and return
/// the abort-flag that is written to true by these handlers.
fn install_abort_handlers() -> ah::Result<Arc<AtomicBool>> {
    let abort = Arc::new(AtomicBool::new(false));
    for sig in &[signal_hook::SIGTERM,
                 signal_hook::SIGINT] {
        if let Err(e) = signal_hook::flag::register(*sig, Arc::clone(&abort)) {
            return Err(ah::format_err!("Failed to register signal {}: {}", sig, e));
        }

    }

    Ok(abort)
}

/// Main program entry point.
fn main() -> ah::Result<()> {
    let args = parse_args(args_os())?;

    // Open the disk device.
    let path = Path::new(&args.device);
    let mut file = match OpenOptions::new().read(args.verify)
                                           .write(args.write)
                                           .create(args.write)
                                           .open(path) {
        Ok(f) => f,
        Err(e) => {
            return Err(ah::format_err!("Failed to open file {:?}: {}", path, e));
        },
    };

    // Generate a random seed, if requested.
    let mut seed = args.seed;
    if args.gen_seed {
        if !args.write {
            return Err(ah::format_err!("Cannot use --gen-seed (-g) and \
                                       --verify (only) mode at the same time. \
                                       Please enable --write mode, too."));
        }
        seed = gen_seed_string(DEFAULT_GEN_SEED_LEN);
        if args.quiet < 2 {
            print_generated_seed(&seed, true);
        }
    }

    // Create the disktest core.
    let abort = install_abort_handlers()?;
    let seed_bytes = seed.as_bytes().to_vec();
    let mut disktest = Disktest::new(args.algorithm,
                                     &seed_bytes,
                                     args.threads,
                                     &mut file,
                                     &path,
                                     args.quiet,
                                     Some(abort));

    // Run write-mode, if requested.
    let mut result = Ok(());
    if args.write {
        result = match disktest.write(args.seek, args.max_bytes) {
            Ok(_) => Ok(()),
            Err(e) => Err(e),
        }
    }

    // Run verify-mode, if requested.
    if args.verify && result.is_ok() {
        result = match disktest.verify(args.seek, args.max_bytes) {
            Ok(_) => Ok(()),
            Err(e) => Err(e),
        }
    }

    if args.gen_seed && args.quiet < 2 {
        print_generated_seed(&seed, false);
    }
    if result.is_ok() && args.quiet < 2 {
        println!("Success!");
    }

    result
}

// vim: ts=4 sw=4 expandtab
